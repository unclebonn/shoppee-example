<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>

<HEAD>

    <TITLE> New Document </TITLE>

    <META NAME="Generator" CONTENT="EditPlus">

    <META NAME="Author" CONTENT="">

    <META NAME="Keywords" CONTENT="">

    <META NAME="Description" CONTENT="">

    <style>
        html,
        body {

            height: 100%;

            padding: 0;

            margin: 0;

            background: #000;

        }

        canvas {

            position: absolute;

            width: 100%;

            height: 100%;

        }

        #modalContainer {
            background-color: rgba(0, 0, 0, 0.3);
            position: absolute;
            top: 0;
            width: 100%;
            height: 100%;
            left: 0px;
            z-index: 10000;
            background-image: url(tp.png);
            /* required by MSIE to prevent actions on lower z-index elements */
        }

        #alertBox {
            position: relative;
            width: 33%;
            min-height: 100px;
            max-height: 400px;
            margin-top: 50px;
            border: 1px solid #fff;
            background-color: #fff;
            background-repeat: no-repeat;
            top: 30%;
        }

        #modalContainer>#alertBox {
            position: fixed;
        }

        #alertBox h1 {
            margin: 0;
            font: bold 1em Raleway, arial;
            background-color: #f97352;
            color: #FFF;
            border-bottom: 1px solid #f97352;
            padding: 10px 0 10px 5px;
        }

        #alertBox p {
            height: 50px;
            padding-left: 5px;
            padding-top: 30px;
            text-align: center;
            vertical-align: middle;
        }

        #alertBox #closeBtn {
            display: block;
            position: relative;
            margin: 10px auto 10px auto;
            padding: 7px;
            border: 0 none;
            width: 70px;
            text-transform: uppercase;
            text-align: center;
            color: #FFF;
            background-color: #f97352;
            border-radius: 0px;
            text-decoration: none;
            outline: 0 !important;
        }

        /* unrelated styles */

        #mContainer {
            position: relative;
            width: 600px;
            margin: auto;
            padding: 5px;
            border-top: 2px solid #fff;
            border-bottom: 2px solid #fff;
        }

        h1,
        h2 {
            margin: 0;
            padding: 4px;
        }

        code {
            font-size: 1.2em;
            color: #069;
        }

        #credits {
            position: relative;
            margin: 25px auto 0px auto;
            width: 350px;
            font: 0.7em verdana;
            border-top: 1px solid #000;
            border-bottom: 1px solid #000;
            height: 90px;
            padding-top: 4px;
        }

        #credits img {
            float: left;
            margin: 5px 10px 5px 0px;
            border: 1px solid #000000;
            width: 80px;
            height: 79px;
        }

        .important {
            background-color: #F5FCC8;
            padding: 2px;

        }
    </style>

</HEAD>


<BODY>

    <canvas id="pinkboard"></canvas>

    <script>

        /*
      
       * Settings
      
       */

        var settings = {

            particles: {

                length: 500, // maximum amount of particles

                duration: 7.5, // particle duration in sec

                velocity: 150, // particle velocity in pixels/sec

                effect: -0.75, // play with this for a nice effect

                size: 30, // particle size in pixels

            },

        };


        /*
        
         * RequestAnimationFrame polyfill by Erik Möller
        
         */

        (function () {
            var b = 0; var c = ["ms", "moz", "webkit", "o"];
            for (var a = 0; a < c.length && !window.requestAnimationFrame; ++a) { window.requestAnimationFrame = window[c[a] + "RequestAnimationFrame"]; window.cancelAnimationFrame = window[c[a] + "CancelAnimationFrame"] || window[c[a] + "CancelRequestAnimationFrame"] }
            if (!window.requestAnimationFrame) { window.requestAnimationFrame = function (h, e) { var d = new Date().getTime(); var f = Math.max(0, 16 - (d - b)); var g = window.setTimeout(function () { h(d + f) }, f); b = d + f; return g } } if (!window.cancelAnimationFrame) { window.cancelAnimationFrame = function (d) { clearTimeout(d) } }
        }());


        /*
        
         * Point class
        
         */

        var Point = (function () {

            function Point(x, y) {

                this.x = (typeof x !== 'undefined') ? x : 0;

                this.y = (typeof y !== 'undefined') ? y : 0;

            }

            Point.prototype.clone = function () {

                return new Point(this.x, this.y);

            };

            Point.prototype.length = function (length) {

                if (typeof length == 'undefined')

                    return Math.sqrt(this.x * this.x + this.y * this.y);

                this.normalize();

                this.x *= length;

                this.y *= length;

                return this;

            };

            Point.prototype.normalize = function () {

                var length = this.length();

                this.x /= length;

                this.y /= length;

                return this;

            };

            return Point;

        })();


        /*
        
         * Particle class
        
         */

        var Particle = (function () {

            function Particle() {

                this.position = new Point();

                this.velocity = new Point();

                this.acceleration = new Point();

                this.age = 0;

            }

            Particle.prototype.initialize = function (x, y, dx, dy) {

                this.position.x = x;

                this.position.y = y;

                this.velocity.x = dx;

                this.velocity.y = dy;

                this.acceleration.x = dx * settings.particles.effect;

                this.acceleration.y = dy * settings.particles.effect;

                this.age = 0;

            };

            Particle.prototype.update = function (deltaTime) {

                this.position.x += this.velocity.x * deltaTime;

                this.position.y += this.velocity.y * deltaTime;

                this.velocity.x += this.acceleration.x * deltaTime;

                this.velocity.y += this.acceleration.y * deltaTime;

                this.age += deltaTime;

            };

            Particle.prototype.draw = function (context, image) {

                function ease(t) {

                    return (--t) * t * t + 1;

                }

                var size = image.width * ease(this.age / settings.particles.duration);

                context.globalAlpha = 1 - this.age / settings.particles.duration;

                context.drawImage(image, this.position.x - size / 2, this.position.y - size / 2, size, size);

            };

            return Particle;

        })();


        /*
        
         * ParticlePool class
        
         */

        var ParticlePool = (function () {

            var particles,

                firstActive = 0,

                firstFree = 0,

                duration = settings.particles.duration;



            function ParticlePool(length) {

                // create and populate particle pool

                particles = new Array(length);

                for (var i = 0; i < particles.length; i++)

                    particles[i] = new Particle();

            }

            ParticlePool.prototype.add = function (x, y, dx, dy) {

                particles[firstFree].initialize(x, y, dx, dy);



                // handle circular queue

                firstFree++;

                if (firstFree == particles.length) firstFree = 0;

                if (firstActive == firstFree) firstActive++;

                if (firstActive == particles.length) firstActive = 0;

            };

            ParticlePool.prototype.update = function (deltaTime) {

                var i;



                // update active particles

                if (firstActive < firstFree) {

                    for (i = firstActive; i < firstFree; i++)

                        particles[i].update(deltaTime);

                }

                if (firstFree < firstActive) {

                    for (i = firstActive; i < particles.length; i++)

                        particles[i].update(deltaTime);

                    for (i = 0; i < firstFree; i++)

                        particles[i].update(deltaTime);

                }



                // remove inactive particles

                while (particles[firstActive].age >= duration && firstActive != firstFree) {

                    firstActive++;

                    if (firstActive == particles.length) firstActive = 0;

                }





            };

            ParticlePool.prototype.draw = function (context, image) {

                // draw active particles

                if (firstActive < firstFree) {

                    for (i = firstActive; i < firstFree; i++)

                        particles[i].draw(context, image);

                }

                if (firstFree < firstActive) {

                    for (i = firstActive; i < particles.length; i++)

                        particles[i].draw(context, image);

                    for (i = 0; i < firstFree; i++)

                        particles[i].draw(context, image);

                }

            };

            return ParticlePool;

        })();


        /*
        
         * Putting it all together
        
         */

        (
            function (canvas) {

                var context = canvas.getContext('2d'),

                    particles = new ParticlePool(settings.particles.length),

                    particleRate = settings.particles.length / settings.particles.duration, // particles/sec

                    time;



                // get point on heart with -PI <= t <= PI

                function pointOnHeart(t) {

                    return new Point(

                        160 * Math.pow(Math.sin(t), 3),

                        130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25

                    );

                }



                // creating the particle image using a dummy canvas

                var image = (function () {

                    var canvas = document.createElement('canvas'),

                        context = canvas.getContext('2d');

                    canvas.width = settings.particles.size;

                    canvas.height = settings.particles.size;

                    // helper function to create the path

                    function to(t) {

                        var point = pointOnHeart(t);

                        point.x = settings.particles.size / 2 + point.x * settings.particles.size / 350;

                        point.y = settings.particles.size / 2 - point.y * settings.particles.size / 350;

                        return point;

                    }

                    // create the path

                    context.beginPath();

                    var t = -Math.PI;

                    var point = to(t);

                    context.moveTo(point.x, point.y);

                    while (t < Math.PI) {

                        t += 0.01; // baby steps!

                        point = to(t);

                        context.lineTo(point.x, point.y);

                    }

                    context.closePath();

                    // create the fill
                    // var color = ['rgb(0,0,300,0.5)', 'red', 'purple'];
                    // var changeColor = 'purple';

                    // color.forEach(element => {
                    //     setTimeout(() => {
                    //         if (element.match('purple')) {
                    //             changeColor = 'rgb(0,0,300,0.5)';
                    //         }
                    //     }, 3000);

                    // });



                    context.fillStyle = "purple";





                    // Fill with gradient


                    context.fill();

                    // create the image

                    var image = new Image();

                    image.src = canvas.toDataURL();

                    return image;

                })();



                // render that thing!

                function render() {

                    // next animation frame

                    requestAnimationFrame(render);



                    // update time

                    var newTime = new Date().getTime() / 1000,

                        deltaTime = newTime - (time || newTime);

                    time = newTime;



                    // clear canvas

                    context.clearRect(0, 0, canvas.width, canvas.height);



                    // create new particles

                    var amount = particleRate * deltaTime;

                    for (var i = 0; i < amount; i++) {

                        var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());

                        var dir = pos.clone().length(settings.particles.velocity);

                        particles.add(canvas.width / 2 + pos.x, canvas.height / 2 - pos.y, dir.x, -dir.y);

                    }



                    // update and draw particles

                    particles.update(deltaTime);

                    particles.draw(context, image);

                }


                // handle (re-)sizing of the canvas

                function onResize() {

                    canvas.width = canvas.clientWidth;

                    canvas.height = canvas.clientHeight;

                }

                window.onresize = onResize;



                // delay rendering bootstrap

                setTimeout(function () {

                    onResize();

                    render();



                }, 10);




            })







            (document.getElementById('pinkboard'));



        //////////////////////////////////////////////////////

        setTimeout(() => {
            (
                function (canvas) {

                    var context = canvas.getContext('2d'),

                        particles = new ParticlePool(settings.particles.length),

                        particleRate = settings.particles.length / settings.particles.duration, // particles/sec

                        time;



                    // get point on heart with -PI <= t <= PI

                    function pointOnHeart(t) {

                        return new Point(

                            160 * Math.pow(Math.sin(t), 3),

                            130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25

                        );

                    }



                    // creating the particle image using a dummy canvas

                    var image = (function () {

                        var canvas = document.createElement('canvas'),

                            context = canvas.getContext('2d');

                        canvas.width = settings.particles.size;

                        canvas.height = settings.particles.size;

                        // helper function to create the path

                        function to(t) {

                            var point = pointOnHeart(t);

                            point.x = settings.particles.size / 2 + point.x * settings.particles.size / 350;

                            point.y = settings.particles.size / 2 - point.y * settings.particles.size / 350;

                            return point;

                        }

                        // create the path

                        context.beginPath();

                        var t = -Math.PI;

                        var point = to(t);

                        context.moveTo(point.x, point.y);

                        while (t < Math.PI) {

                            t += 0.01; // baby steps!

                            point = to(t);

                            context.lineTo(point.x, point.y);

                        }

                        context.closePath();

                        // create the fill
                        // var color = ['rgb(0,0,300,0.5)', 'red', 'purple'];
                        // var changeColor = 'purple';

                        // color.forEach(element => {
                        //     setTimeout(() => {
                        //         if (element.match('purple')) {
                        //             changeColor = 'rgb(0,0,300,0.5)';
                        //         }
                        //     }, 3000);

                        // });



                        context.fillStyle = "rgb(0,0,300,0.5)";





                        // Fill with gradient


                        context.fill();

                        // create the image

                        var image = new Image();

                        image.src = canvas.toDataURL();

                        return image;

                    })();



                    // render that thing!

                    function render() {

                        // next animation frame

                        requestAnimationFrame(render);



                        // update time

                        var newTime = new Date().getTime() / 1000,

                            deltaTime = newTime - (time || newTime);

                        time = newTime;



                        // clear canvas

                        context.clearRect(0, 0, canvas.width, canvas.height);



                        // create new particles

                        var amount = particleRate * deltaTime;

                        for (var i = 0; i < amount; i++) {

                            var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());

                            var dir = pos.clone().length(settings.particles.velocity);

                            particles.add(canvas.width / 2 + pos.x, canvas.height / 2 - pos.y, dir.x, -dir.y);

                        }



                        // update and draw particles

                        particles.update(deltaTime);

                        particles.draw(context, image);

                    }


                    // handle (re-)sizing of the canvas

                    function onResize() {

                        canvas.width = canvas.clientWidth;

                        canvas.height = canvas.clientHeight;

                    }

                    window.onresize = onResize;



                    // delay rendering bootstrap

                    setTimeout(function () {

                        onResize();

                        render();



                    }, 10);




                })

                /////////////////////

                (document.getElementById('pinkboard'));
        }, 5500);


        setTimeout(() => {
            (
                function (canvas) {

                    var context = canvas.getContext('2d'),

                        particles = new ParticlePool(settings.particles.length),

                        particleRate = settings.particles.length / settings.particles.duration, // particles/sec

                        time;



                    // get point on heart with -PI <= t <= PI

                    function pointOnHeart(t) {

                        return new Point(

                            160 * Math.pow(Math.sin(t), 3),

                            130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25

                        );

                    }



                    // creating the particle image using a dummy canvas

                    var image = (function () {

                        var canvas = document.createElement('canvas'),

                            context = canvas.getContext('2d');

                        canvas.width = settings.particles.size;

                        canvas.height = settings.particles.size;

                        // helper function to create the path

                        function to(t) {

                            var point = pointOnHeart(t);

                            point.x = settings.particles.size / 2 + point.x * settings.particles.size / 350;

                            point.y = settings.particles.size / 2 - point.y * settings.particles.size / 350;

                            return point;

                        }

                        // create the path

                        context.beginPath();

                        var t = -Math.PI;

                        var point = to(t);

                        context.moveTo(point.x, point.y);

                        while (t < Math.PI) {

                            t += 0.01; // baby steps!

                            point = to(t);

                            context.lineTo(point.x, point.y);

                        }

                        context.closePath();

                        // create the fill
                        // var color = ['rgb(0,0,300,0.5)', 'red', 'purple'];
                        // var changeColor = 'purple';

                        // color.forEach(element => {
                        //     setTimeout(() => {
                        //         if (element.match('purple')) {
                        //             changeColor = 'rgb(0,0,300,0.5)';
                        //         }
                        //     }, 3000);

                        // });



                        context.fillStyle = "rgb(135,206,250)";





                        // Fill with gradient


                        context.fill();

                        // create the image

                        var image = new Image();

                        image.src = canvas.toDataURL();

                        return image;

                    })();



                    // render that thing!

                    function render() {

                        // next animation frame

                        requestAnimationFrame(render);



                        // update time

                        var newTime = new Date().getTime() / 1000,

                            deltaTime = newTime - (time || newTime);

                        time = newTime;



                        // clear canvas

                        context.clearRect(0, 0, canvas.width, canvas.height);



                        // create new particles

                        var amount = particleRate * deltaTime;

                        for (var i = 0; i < amount; i++) {

                            var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());

                            var dir = pos.clone().length(settings.particles.velocity);

                            particles.add(canvas.width / 2 + pos.x, canvas.height / 2 - pos.y, dir.x, -dir.y);

                        }



                        // update and draw particles

                        particles.update(deltaTime);

                        particles.draw(context, image);

                    }


                    // handle (re-)sizing of the canvas

                    function onResize() {

                        canvas.width = canvas.clientWidth;

                        canvas.height = canvas.clientHeight;

                    }

                    window.onresize = onResize;



                    // delay rendering bootstrap

                    setTimeout(function () {

                        onResize();

                        render();



                    }, 10);




                })

                /////////////////////

                (document.getElementById('pinkboard'));
        }, 5500);



        setTimeout(() => {
            alert('Làm bạn gái anh nha !');
        }, 10000);




        var ALERT_TITLE = "Thư mục tỏ tình!";
        var ALERT_BUTTON_TEXT = "Đồng ý";

        if (document.getElementById) {
            window.alert = function (txt) {
                createCustomAlert(txt);
            }
        }

        function createCustomAlert(txt) {
            d = document;

            if (d.getElementById("modalContainer")) return;

            mObj = d.getElementsByTagName("body")[0].appendChild(d.createElement("div"));
            mObj.id = "modalContainer";
            mObj.style.height = d.documentElement.scrollHeight + "px";

            alertObj = mObj.appendChild(d.createElement("div"));
            alertObj.id = "alertBox";
            if (d.all && !window.opera) alertObj.style.top = document.documentElement.scrollTop + "px";
            alertObj.style.left = (d.documentElement.scrollWidth - alertObj.offsetWidth) / 2 + "px";
            alertObj.style.visiblity = "visible";

            h1 = alertObj.appendChild(d.createElement("h1"));
            h1.appendChild(d.createTextNode(ALERT_TITLE));

            msg = alertObj.appendChild(d.createElement("p"));
            //msg.appendChild(d.createTextNode(txt));
            msg.innerHTML = txt;

            btn = alertObj.appendChild(d.createElement("a"));
            btn.id = "closeBtn";
            btn.appendChild(d.createTextNode(ALERT_BUTTON_TEXT));
            btn.href = "#";
            btn.focus();
            btn.onclick = function () { removeCustomAlert(); return false; }

            alertObj.style.display = "block";

        }

        function removeCustomAlert() {
            document.getElementsByTagName("body")[0].removeChild(document.getElementById("modalContainer"));
        }
        function ful() {
            alert('Alert this pages');
        }
    </script>


</BODY>

</HTML>